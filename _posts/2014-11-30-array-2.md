---
layout: post
title: java基础示例——Array(二)
description: "本系列主要演示一些java的基础示例，综合比较java7、java8、Google Guava、Apache Commons 等实现的异同。<br/>
              例子简单, 以积硅步, 至千里。"
category: [blog, java, examples]
tags : [java, 示例, 翻译]
duoshuo: false
---

[返回总目录]({% post_url 2014-11-29-java-base-examples %})<br/>
[Array(一)]({% post_url 2014-11-29-array-1 %})

## 数组最大值
用java、java8、guava和apcache commons求数组最小值。

### 准备
遍历数组中的每一个元素，并与之前的元素比较，如果当前元素值大于最大值，保存这个最大值，直到循环结束。

<pre class='brush: java'>
int[] numbers = {1, 24, 45, 62, 85, 8, 91, 3, 5, 56, 9};
</pre>
<!-- more -->

### Java
<pre class='brush: java'>
@Test
public void find_max_value_in_numeric_array_with_java () {

    int highest = numbers[0];
    for (int index = 1; index < numbers.length; index ++) {
        if (numbers[index] > highest) {
            highest = numbers [index];
        }
    }
    assertEquals(91, highest);
}
</pre>

### Java 8
Java 8包含了将数字数组转换成`Stream`的方法，通过它，仅用`Stream.max`方法就能求出数组最大值，这个方法返回`OptionalInt`。或者用`IntStream.of`也可以达到
相同的效果。

<pre class='brush: java'>
@Test
public void find_max_value_in_numeric_array_with_java8 () {

    OptionalInt highest = Arrays.stream(numbers).max();

    assertEquals(91, highest.getAsInt());

    // or

    OptionalInt highest2 = IntStream.of(numbers).max();

    assertEquals(91, highest2.getAsInt());
}
</pre>

### Google Guava

<pre class='brush: java'>
@Test
public void find_max_value_in_numeric_array_with_guava () {
    int highest = Ints.max(numbers);
    assertEquals(91, highest);
}
</pre>

### Apache Commons
Apache commons的`NumberUtils`提供了对java数字类型的附加功能，包括用`NumberUtils.max`求和。

<pre class='brush: java'>
@Test
public void find_max_value_in_array_with_apache_commons () {
    int highest = NumberUtils.max(numbers);
    assertEquals(91, highest);
}
</pre>
---

## 数组最小值

### 准备
<pre class='brush: java'>
int[] numbers = {1, 24, 45, 62, 85, 8, 91, 3, 5, 56, 9};
</pre>

### Java
与求数组最大值相似

<pre class='brush: java'>
@Test
public void find_min_value_in_numeric_array_with_java () {

    int lowest = numbers[0];
    for (int index = 1; index < numbers.length; index ++) {
        if (numbers[index] < lowest) {
            lowest = numbers [index];
        }
    }
    assertEquals(1, lowest);
}
</pre>

### Java 8

<pre class='brush: java'>
@Test
public void find_min_value_in_numeric_array_with_java8 () {

    OptionalInt lowest = Arrays.stream(numbers).min();

    assertEquals(1, lowest.getAsInt());

    // or

    OptionalInt lowest2 = IntStream.of(numbers).min();

    assertEquals(1, lowest2.getAsInt());
}
</pre>

### Google Guava

<pre class='brush: java'>
@Test
public void find_min_value_in_numeric_array_with_guava () {
    int lowest = Ints.min(numbers);
    assertEquals(1, lowest);
}
</pre>

### Apache Commons

<pre class='brush: java'>
@Test
public void find_min_value_in_array_with_apache_commons () {
    int lowest = NumberUtils.min(numbers);
    assertEquals(1, lowest);
}
</pre>
---

## 移除数组元素
`ArrayUtils.removeElement`方法用于移除数组中的元素，它会删除它找到的第一次出现的元素，然后将所有元素向左侧移动。

### Apache Commons
<pre class='brush: java'>
@Test
public void remove_element_from_array_apache_commons () {

    String[] daysOfWeek = {"Sunday", "Monday", "Tuesday", "Wednesday",
            "Thursday", "Friday", "Saturday"};

    String[] favoriteDaysOfTheWeek = ArrayUtils.removeElement(daysOfWeek, "Monday");

    logger.info(Arrays.toString(daysOfWeek));

    assertTrue(favoriteDaysOfTheWeek.length == 6);
    assertThat(favoriteDaysOfTheWeek, arrayContaining(
            "Sunday", "Tuesday", "Wednesday",
            "Thursday", "Friday", "Saturday"));

}
</pre>
---

## 反转数组
这个例子演示如何用java原生方法和apache commons的`ArrayUtils.reverse`方法反转数组元素。这也可以通过反向排序的方式完成。

### 准备
<pre class='brush: java'>
String[] MONTHS_OF_YEAR_BACKWARDS;

@Before
public void setUp () {
    MONTHS_OF_YEAR_BACKWARDS = new String[] {
            "December",
            "November",
            "October",
            "September",
            "August",
            "July",
            "June",
            "May",
            "April",
            "March",
            "February",
            "January"
    };
}
</pre>

### Java
<pre class='brush: java'>
@Test
public void reverse_elements_in_array_with_java () {

    for (int i=0; i < MONTHS_OF_YEAR_BACKWARDS.length / 2; i++) {

        // 设置当前元素的临时变量
        String temp = MONTHS_OF_YEAR_BACKWARDS[i];

        // 找到最后一个元素 - 1
        int j = MONTHS_OF_YEAR_BACKWARDS.length - i - 1;

        // 把第一个元素放到数组未尾
        MONTHS_OF_YEAR_BACKWARDS[i] = MONTHS_OF_YEAR_BACKWARDS[j];

        // 把最后一个元素放到第一位
        MONTHS_OF_YEAR_BACKWARDS[j] = temp;
    }

    logger.info(Arrays.toString(MONTHS_OF_YEAR_BACKWARDS));

    assertEquals("May", MONTHS_OF_YEAR_BACKWARDS[4]);
}
</pre>
输出
<pre class='brush: java'>
[January, February, March, April, May, June, July, August, September, October, November, December]
</pre>

### Apache Commons
<pre class='brush: java'>
@Test
public void reverse_elements_in_array_with_apache_commons () {

    ArrayUtils.reverse(MONTHS_OF_YEAR_BACKWARDS);

    logger.info(Arrays.toString(MONTHS_OF_YEAR_BACKWARDS));

    assertEquals("May", MONTHS_OF_YEAR_BACKWARDS[4]);
}
</pre>
输出
<pre class='brush: java'>
[January, February, March, April, May, June, July, August, September, October, November, December]
</pre>
---

## 移动数组元素

### Java
<pre class='brush: java'>
@Test
public void shift_values_in_array_with_java () {

    String[] shoeTypes = {
            "Nike",
            "Puma",
            "Converse",
            "Reebok",
            "Asics"};

    String[] shoeTypesMinusNike = new String[shoeTypes.length - 1];
    System.arraycopy(shoeTypes, 1, shoeTypesMinusNike, 0, shoeTypes.length - 1);

    logger.info(shoeTypesMinusNike);

    assertTrue(Arrays.binarySearch(shoeTypesMinusNike, "Nike") < 0);
}
</pre>
输出
<pre class='brush: java'>
[Puma, Converse, Reebok, Asics]
</pre>
---

## 数组排序

### Java

#### 数字数组升序

<pre class='brush: java'>
@Test
public void sort_numeric_array_in_java () {

    int[] uwConferenceTitles = {
            1896, 2011, 1901, 1912, 1952,
            1959, 1962, 1999, 1897, 1906,
            1993, 1998,  2010,  2012};

    Arrays.sort(uwConferenceTitles);

    logger.info(Arrays.toString(uwConferenceTitles));

    assertArrayEquals(new int[] {
            1896, 1897, 1901, 1906, 1912,
            1952, 1959, 1962, 1993, 1998,
            1999, 2010, 2011, 2012},
            uwConferenceTitles);
}
</pre>

#### 数字数组降序
用Arrays.sort带比较器的重载方法，传入`Collections.reverseOrder`改变数组排序方式。

<pre class='brush: java'>
@Test
public void sort_numeric_array_decending_in_java () {

    Integer[] uwConferenceTitles = {
            1896, 2011, 1901, 1912, 1952,
            1959, 1962, 1999, 1897, 1906,
            1993, 1998,  2010,  2012};

    Arrays.sort(uwConferenceTitles, Collections.reverseOrder());

    logger.info(Arrays.toString(uwConferenceTitles));

    assertArrayEquals(new Integer[] {
            2012, 2011, 2010, 1999, 1998,
            1993, 1962, 1959, 1952, 1912,
            1906, 1901, 1897, 1896},
            uwConferenceTitles);

}
</pre>

### Java 8

#### 数字数组升序
IntStream has two sister streams, double stream and long stream if you dealing with primitive double and long respectively.
在Java 8中用`IntStrem`（类似的还有DoubleStream和LongStream）进行排序，首先用`IntStream.of`方法创建Stream，再用`sorted`进行排序。

<pre class='brush: java'>
@Test
public void sort_numeric_array_in_java8() {

    int[] uwConferenceTitles = { 1896, 2011, 1901, 1912, 1952, 1959, 1962,
            1999, 1897, 1906, 1993, 1998, 2010, 2012 };

    int[] sortedTitles = IntStream.of(uwConferenceTitles).sorted()
            .toArray();

    logger.info(Arrays.toString(uwConferenceTitles));

    assertArrayEquals(new int[] { 1896, 1897, 1901, 1906, 1912, 1952, 1959,
            1962, 1993, 1998, 1999, 2010, 2011, 2012 }, sortedTitles);
}
</pre>

#### 数字数组降序
用Lambda表达示创建一个比较器，然后在Arrays.sort中这个比较器。

<pre class='brush: java'>
@Test
public void sort_numeric_array_decending_in_java8 () {

    Integer[] uwConferenceTitles = {
            1896, 2011, 1901, 1912, 1952,
            1959, 1962, 1999, 1897, 1906,
            1993, 1998,  2010,  2012};

    Comparator<Integer> normal = Integer::compare;
    Comparator<Integer> reversed = normal.reversed();

    Arrays.sort(uwConferenceTitles, reversed);

    assertArrayEquals(new Integer[] {
            2012, 2011, 2010, 1999, 1998,
            1993, 1962, 1959, 1952, 1912,
            1906, 1901, 1897, 1896},
            uwConferenceTitles);
}
</pre>

#### 字符串数组排序

<pre class='brush: java'>
@Test
public void sort_string_array_in_java8 () {

    String[] wiStateParks = {
            "Mill Bluff State Park",
            "Amnicon Falls State Park",
            "Wyalusing State Park",
            "Big Foot Beach State Park",
            "Willow River State Park",
            "Roche-A-Cri State Park"
        };

    Object[] sorted = Arrays.stream(wiStateParks).sorted().toArray();

    logger.info(Arrays.toString(sorted));

    assertArrayEquals(new String[] {
            "Amnicon Falls State Park",
            "Big Foot Beach State Park",
            "Mill Bluff State Park",
            "Roche-A-Cri State Park",
            "Willow River State Park",
            "Wyalusing State Park"},
            sorted);

}
</pre>

#### 根据长度对字符串数组进行排序
By using a lambda expresison, we will abstract specific details of how to sort and focus on creating a simple comparator
comparing the strings length.


<pre class='brush: java'>
@Test
public void sort_string_array_in_java8_by_length () {

    String[] wiStateParks = {
            "Mill Bluff State Park",
            "Amnicon Falls State Park",
            "Wyalusing State Park",
            "Big Foot Beach State Park",
            "Willow River State Park",
            "Roche-A-Cri State Park"
        };

    Arrays.sort(wiStateParks, (s1, s2) -> s1.length() - s2.length());

    logger.info(Arrays.toString(wiStateParks));

    //or Arrays.sort(wiStateParks, (String s1, String s2) -> s1.length() - s2.length());

    assertArrayEquals(new String[] { "Wyalusing State Park",
            "Mill Bluff State Park", "Roche-A-Cri State Park",
            "Willow River State Park", "Amnicon Falls State Park",
            "Big Foot Beach State Park" }, wiStateParks);
}
</pre>

### Google Guava
`Ordering`是guava“加强版”的比较器类，用以灵活地创建、链式调用和执行数组排序。

#### 对数字数组降序排序
<pre class='brush: java'>
@Test
public void sort_numeric_array_decending_in_java_with_guava () {

    Integer[] uwConferenceTitles = {
            1896, 2011, 1901, 1912, 1952,
            1959, 1962, 1999, 1897, 1906,
            1993, 1998,  2010,  2012};

    Arrays.sort(uwConferenceTitles, Ordering.natural().reverse());

    logger.info(Arrays.toString(uwConferenceTitles));

    assertArrayEquals(new Integer[] {
            2012, 2011, 2010, 1999, 1998,
            1993, 1962, 1959, 1952, 1912,
            1906, 1901, 1897, 1896},
            uwConferenceTitles);
}
</pre>

#### 字符串数组根据长度排序
<pre class='brush: java'>
@Test
public void sort_string_array_in_java_with_guava_by_length () {

    Ordering<String> byLengthOrdering = new Ordering<String>() {
        public int compare(String left, String right) {
            return Ints.compare(left.length(), right.length());
        }
    };

    String[] wiStateParks = { "Mill Bluff State Park",
            "Amnicon Falls State Park", "Wyalusing State Park",
            "Big Foot Beach State Park", "Willow River State Park",
            "Roche-A-Cri State Park" };

    Arrays.sort(wiStateParks, byLengthOrdering);

    logger.info(Arrays.toString(wiStateParks));

    assertArrayEquals(new String[] { "Wyalusing State Park",
            "Mill Bluff State Park", "Roche-A-Cri State Park",
            "Willow River State Park", "Amnicon Falls State Park",
            "Big Foot Beach State Park" }, wiStateParks);
}
</pre>
---

## 数组求和
用java, java 8和apache commons对数组求和。

### 准备
<pre class='brush: java'>
double[] numbers = {1, 24, 45, 62, 85, 8, 91, 3, 5, 56, 9};
</pre>

### Java
<pre class='brush: java'>
@Test
public void sum_values_in_array_with_java () {

    double total = 0;
    for (double element : numbers) {
        total += element;
    }
    assertEquals(389, total, 0);
}
</pre>

###Java 8
Java 8 的Stream包含的`reduce operations`提共了一个求和的内部实现，跟上边的数组求和方式相比，它更简洁、更易于维护和更能表明意图。
提供可选的`stream.parallel`以实现并行Streams。

<pre class='brush: java'>
@Test
public void sum_values_in_array_with_java_8 () {

    double total = DoubleStream.of(numbers).sum();

    assertEquals(389, total, 0);

    // or

    double total2 = Arrays.stream(numbers).sum();

    assertEquals(389, total2, 0);
}
</pre>

### Apache Commons

<pre class='brush: java'>
@Test
public void sum_values_in_array_with_apache_commons () {

    double total = StatUtils.sum(numbers);
    assertEquals(389, total, 0);
}
</pre>
---

原文:[http://www.leveluplunch.com/java/examples](http://www.leveluplunch.com/java/examples#java-array)