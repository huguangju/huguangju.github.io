import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as i,b as n,o as t}from"./app-CmPTslM6.js";const l={};function r(d,s){return t(),a("div",null,[s[0]||(s[0]=i('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>缓存的合理使用可<strong>提升网页性能</strong>。</p><h3 id="什么是缓存-cache" tabindex="-1"><a class="header-anchor" href="#什么是缓存-cache"><span>什么是缓存（cache）？</span></a></h3><p>缓存是计算机系统中的一种技术，用于临时存储经常访问的数据，以加快数据访问速度。缓存通常位于数据访问路径的中间，可以在数据访问时快速提供数据，而无需每次都从原始数据源获取数据。缓存可以是硬件或软件实现的，可以在多个层次上实现，例如浏览器缓存、操作系统缓存、CPU 缓存等。缓存的使用可以显著提高系统性能，减少对原始数据源的访问次数，从而减少系统资源的占用和延迟。</p><p>可以看出，缓存的重点在于<strong>访问速度快、性能高</strong>。</p>',5)),n(" more "),s[1]||(s[1]=i(`<h3 id="什么是前端缓存" tabindex="-1"><a class="header-anchor" href="#什么是前端缓存"><span>什么是前端缓存？</span></a></h3><p><strong>前端缓存</strong>可以直接看作是 <strong>HTTP 缓存</strong>和<strong>浏览器缓存</strong>的结合，两者相辅相成。</p><p><strong>HTTP 缓存</strong>：客户端与服务器之间通信产生的一种缓存，用其以提升服务器资源的重复利用率（有效时间内不向服务器请求相同资源，减少服务器压力）；</p><p><strong>浏览器缓存</strong>：浏览器提供的一种缓存机制，可以将服务器资源和网页访问产生的临时数据缓存到内存或本地，提升客户端的加载速度。</p><h3 id="前端有哪此缓存" tabindex="-1"><a class="header-anchor" href="#前端有哪此缓存"><span>前端有哪此缓存？</span></a></h3><p>可按分类方式和细分程度划分。如：</p><ul><li>HTTP 缓存 <ul><li>按照<strong>失效策略</strong>划分：强缓存、协商缓存。</li></ul></li><li>浏览器缓 <ul><li>按照<strong>缓存位置</strong>划分：Service Worker Cache、Memory Cache、Disk Cache、Push Cache。</li><li>存储型缓存： Cookie、Web Storage、IndexedDB 等。</li></ul></li></ul><blockquote><p>前端会使用 CDN 缓存加速静态文件，但 CDN 本质上属于服务端缓存。</p></blockquote><h2 id="http-缓存" tabindex="-1"><a class="header-anchor" href="#http-缓存"><span>HTTP 缓存</span></a></h2><blockquote><p>HTTP 是一种能够获取如 HTML 这样的网络资源的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol" target="_blank" rel="noopener noreferrer">protocol</a>(通讯协议)。它是在 Web 上进行数据交换的基础，是一种 client-server 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。一个完整的 Web 文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。</p></blockquote><p>前端接触到的为 HTTP 请求部分，主要发生在客户端。请求是由“报文”的形式发送的，请求报文由三部分组成：<strong>请求行、请求报头</strong>和<strong>请求正文</strong>。HTTP 响应部分的响应报文也由三部分组成：<strong>状态行</strong>、<strong>响应报头</strong>和<strong>响应正文</strong>。</p><p>关键与缓存有关的 <strong>请求报头</strong>和 <strong>响应报头</strong>，即浏览器 Network 面板中常见的 <code>Request Headers</code> 和 <code>Response Headers</code> 部分。 报头是由一系列中间用冒号 “:” 分隔的键值对组成，称之为<strong>首部字段</strong>，其由首部字段名和字段值构成。如： <code>Content-Type: text/javascript</code> 以上首部字段名为 Content-Type，首部字段值为 text/javascript，表示报文主体的对象类型。</p><p>首部字段又分为四种类型：</p><ul><li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.5" target="_blank" rel="noopener noreferrer">通用</a>（请求报头和响应报头都会用到）</li><li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.3" target="_blank" rel="noopener noreferrer">请求</a>（请求报头用到）</li><li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.2" target="_blank" rel="noopener noreferrer">响应</a>（响应报头用到）</li><li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.1" target="_blank" rel="noopener noreferrer">实体</a>（针对请求报头和响应报头实体部分使用）</li></ul><h3 id="与缓存有关的首部字段名" tabindex="-1"><a class="header-anchor" href="#与缓存有关的首部字段名"><span>与缓存有关的首部字段名</span></a></h3><p>上面提到的 HTTP 缓存可以拆解为 <strong>强缓存</strong> 和 <strong>协商缓存</strong>，所以需要弄清楚和强缓存、协商缓存有关的首部字段名。</p><div class="language-mermaid line-numbers-mode" data-highlighter="shiki" data-ext="mermaid" data-title="mermaid" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">graph LR;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  A[HTTP缓存]--&gt;B[强缓存];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  A--&gt;C[协商缓存];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  B--&gt;D[Expires];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  E--&gt;K[max-age];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  E--&gt;L[s-maxage];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  B--&gt;E[Cache-Control];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  E--&gt;G[public/private];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  E--&gt;I[no-cache/no-store];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  E--&gt;J[...];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  C--&gt;M[Last-Modified];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  C--&gt;O[If-Modified-Since];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  C--&gt;N[ETag];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  C--&gt;P[If-None-Match];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="expires" tabindex="-1"><a class="header-anchor" href="#expires"><span>Expires</span></a></h4><p>在 HTTP/1.0 中定义缓存的字段，其给出了缓存过期的<strong>绝对时间</strong>，即在此时间之后，响应资源过期，属于<strong>实体首部字段</strong>。</p><div class="language-http line-numbers-mode" data-highlighter="shiki" data-ext="http" data-title="http" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Expires</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Wed, 11 May 2023 03:50:47 GMT</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>表示该资源将在指定时间之后过期，过期前浏览器可以直接从浏览器缓中读取数据，无需再次请求服务器（命即中了强缓存）。</p><blockquote><p>因为 Expires 设置的缓存过期时间是一个绝对时间，所以会<strong>受客户端时间的影响</strong>而变得不精准。</p></blockquote><h4 id="cache-control" tabindex="-1"><a class="header-anchor" href="#cache-control"><span>Cache-Control</span></a></h4><p>在 HTTP/1.1 中定义缓存的字段，其用于<strong>控制缓存的行为</strong>。可以组合使用多种指令（指令间通过 “,” 分隔），属于<strong>通用首部字段</strong>。常用指令有：max-age、s-maxage、public/private、no-cache/no store 等。</p><div class="language-http line-numbers-mode" data-highlighter="shiki" data-ext="http" data-title="http" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Cache-Control</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> max-age:3600, s-maxage=3600, public</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Cache-Control</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> no-cache</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>max-age</code> 指令给出了缓存过期的<strong>相对时间</strong>（单位：秒）。当其与 <code>Expires</code> 同时出现时，<strong>max-age 的优先级更高</strong>。但往往为了做向下兼容，两者都会经常出现在响应首部中。</p><p>max-age 还可在请求首部中被使用，告知服务器客户端希望接收一个存在时间（age）不大于多少秒的资源。</p><p>而 <code>s-maxage</code> 与 max-age 不同之处在于，其只适用于公共缓存服务器，比如资源从源服务器发出后又被中间的代理服务器接收并缓存。 <strong>当使用 s-maxage 指令后，公共缓存服务器将直接忽略 Expires 和 max-age 指令的值。</strong></p><p><code>public</code> 指令表示该资源可以被任何节点缓存（包括客户端和代理服务器），与其行为相反的 <code>private</code> 指令表示该资源只提供给客户端缓存，代理服务器不会进行缓存。<strong>同时当设置了 private 指令后 s-maxage 指令将被忽略</strong>。</p><p><code>no-cache</code>、<code>no-store</code> 两个指令<strong>在请求和响应中都可以使用</strong>。两者看上去都代表不缓存，但在响应首部中被使用时， <code>no-store</code> 才是真正的不进行任何缓存。</p><p>当 no-cache 在请求首部中被使用时，表示告知（代理）服务器不直接使用缓存，要求向源服务器发起请求，而当在响应首部中被返回时，表示客户端可以缓存资源，但每次使用缓存资源前都<strong>必须</strong>先向服务器确认其有效性，这对每次访问都需要确认身份的应用来说很有用。</p><p>也可以在代码里加入 meta 标签的方式来修改资源的请求首部：</p><div class="language-html line-numbers-mode" data-highlighter="shiki" data-ext="html" data-title="html" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">meta</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> http-equiv</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Cache-Control&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> content</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;no-cache&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>接下来再看看协商缓存中涉及的主要首部字段名。</p><h4 id="last-modified-与-if-modified-since" tabindex="-1"><a class="header-anchor" href="#last-modified-与-if-modified-since"><span>Last-Modified 与 If-Modified-Since</span></a></h4><p>代表资源的最后修改时间，其属于<strong>响应首部字段</strong>。当浏览器第一次接收到服务器返回资源的 Last-Modified 值后，其会把这个值存储起来，并再下次访问该资源时通过携带 If-Modified-Since 请求首部发送给服务器验证该资源有没有过期。</p><div class="language-http line-numbers-mode" data-highlighter="shiki" data-ext="http" data-title="http" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Last-Modified</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Fri, 14 May 2023 17:23:13 GMT</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">If-Modified-Since</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Fri, 14 May 2023 17:23:13 GMT</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在 If-Modified-Since 字段指定的时间之后<strong>资源发生了更新</strong>，那么服务器会将更新的资源发送给浏览器（状态码200）并返回最新的 Last-Modified 值，浏览器收到资源后会更新缓存的 If-Modified-Since 的值。</p><p>如果在 If-Modified-Since 字段指定的时间之后<strong>资源都未更新</strong>，那么服务器会返回状态码 <code>304 Not Modified</code> 的响应。</p><h4 id="etag-与-if-none-match" tabindex="-1"><a class="header-anchor" href="#etag-与-if-none-match"><span>Etag 与 If-None-Match</span></a></h4><p>Etag 首部字段用于<strong>代表资源的唯一性标识</strong>，服务器会按照指定的规则生成资源的标识，其属于<strong>响应首部字段</strong>。当资源发生变化时，Etag 的标识也会更新。同样的，当浏览器第一次接收到服务器返回资源的 Etag 值后，其会把这个值存储起来，并在下次访问该资源时通过携带 If-None-Match 请求首部发送给服务器验证该资源有没有过期。</p><div class="language-http line-numbers-mode" data-highlighter="shiki" data-ext="http" data-title="http" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Etag</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;29322-09SpAhH3nXWd8KIVqB10hSSz66&quot;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">If-None-Match</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;29322-09SpAhH3nXWd8KIVqB10hSSz66&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果服务器发现 If-None-Match 值与 Etag 不一致时，说明服务器上的文件已经被更新，那么服务器会发送更新后的资源给浏览器并返回最新的 Etag 值，浏览器收到资源后会更新缓存的 If-None-Match 的值。</p><h3 id="强缓存" tabindex="-1"><a class="header-anchor" href="#强缓存"><span>强缓存</span></a></h3><p><strong>强缓存的生成过程：</strong></p><p>当浏览器发起 HTTP 请求时，会查询浏览器缓存是否缓存有该资源，那么浏览器便会向服务器发起请求，服务器接收请求后将资源返回给浏览器，浏览器会<strong>将资源的响应数据存储到浏览器缓存中</strong>。</p><h4 id="max-age-与-s-maxage" tabindex="-1"><a class="header-anchor" href="#max-age-与-s-maxage"><span>max-age 与 s-maxage</span></a></h4><p><strong>强缓存的生成过程</strong>：当浏览器第一次发起 HTTP 请求时，若浏览器缓存中没有该资源的缓存数据，浏览器会向服务器发起请求，服务器返回资源数据，浏览器将其存储到缓存中。</p><blockquote><p>强缓存不仅限于 Disk cache，还包括 Memory Cache（内存缓存）。内存缓存更快，会被浏览器优先读取。</p></blockquote><p>被浏览器缓存的资源，响应报头中都包含了与强缓存有关的首部字段：<code>Expires</code> 或 <code>Cache-Control</code>，如 <code>max-age=2592000,s-maxage=3600</code>。</p><p><strong><code>s-maxage</code> 仅在代理服务器中生效，优先级高于 <code>max-age</code></strong>。</p><h4 id="expires-与-max-age" tabindex="-1"><a class="header-anchor" href="#expires-与-max-age"><span>expires 与 max-age</span></a></h4><p><code>expires</code> 设置的缓存过期时间是一个<strong>绝对时间</strong>，所以会受<strong>客户端时间</strong>的影响而变得不精准。</p><p><code>max-age</code> 则是<strong>相对时间</strong>，起始时间从浏览器获取并缓存该资源的时间算。但若修改客户端时间为 <code>max-age</code> 指定时间之后，<strong>缓存也会失效</strong>。</p><h3 id="缓存新鲜度与使用期算法" tabindex="-1"><a class="header-anchor" href="#缓存新鲜度与使用期算法"><span>缓存新鲜度与使用期算法</span></a></h3><p>类比食品保质期，强缓存也有“保质期”，一般称其为“新鲜度”。判断强缓存是否新鲜的公式则为：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>强缓存是否新鲜 = 缓存新鲜度 &gt; 缓存使用期</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>强缓存是否新鲜取决于两个关键词：缓存新鲜度和缓存使用期。</p><h4 id="缓存新鲜度" tabindex="-1"><a class="header-anchor" href="#缓存新鲜度"><span>缓存新鲜度</span></a></h4><p>在浏览器中强缓存的保质期限怎么计算？</p><p>缓存的新鲜度公式如下：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">缓存新鲜度 </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> max</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">age</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> ||</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">expires</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> date</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>即，当 <code>max-age</code> 存在时，缓存新鲜度等于 max-age 表示的时间单位长度（s）。当 max-age 不存在时，缓存新鲜度等于 <code>expires - date</code> 的值。</p><p>其中，首部字段 <strong><code>date</code></strong> 表示创建报文的日期时间，可以理解为服务器（包含源服务器和代理服务器）返回新资源的时间（绝对时间）。</p><h4 id="使用期算法" tabindex="-1"><a class="header-anchor" href="#使用期算法"><span>使用期算法</span></a></h4><p>缓存使用期：可以理解为浏览器已经使用该资源的时间。主要与响应使用期、传输延迟时间和停留缓存时间有关，计算公式如下：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>缓存使用期 = 响应使用期 + 传输延迟时间 + 停留缓存时间</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">响应使用期、传输延迟时间 与 停留缓存时间</p><p><strong>响应使用期</strong> 可通过两种方式计算：</p><ul><li><code>max(0, response_time - date_value)</code></li><li><code>age_value</code></li></ul><blockquote><p><code>response_time</code> 是浏览器缓存收到响应的本地时间，<code>date_value</code> 即上文提到的 <code>date</code> 首部。<code>Age</code> 表示资源在缓存代理服务器中存贮的时长（s）</p></blockquote><p>将以上两种方式进行组合:</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>apparent_age = max(0, response_time - date_value) </span></span>
<span class="line"><span>响应使用期 = max(apparent_age, age_value)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>传输延迟时间</strong> 可以理解为浏览器缓存发起请求到收到响应的时间差，其计算公式为：</p><p><code>传输延迟时间 = response_time - request_time</code></p><blockquote><p><code>response_time</code> 和 <code>request_time</code> 分别代表浏览器缓存收到响应和发起请求的本地时间</p></blockquote><p><strong>停留缓存时间</strong> 表示资源在浏览器上已经缓存的时间，其计算公式为：</p><p><code>停留缓存时间 = now - response_time</code></p><blockquote><p><code>now</code> 代表电脑客户端的当前时间，<code>response_time</code> 代表浏览器缓存收到响应的本地时间</p></blockquote></div><div class="hint-container info"><p class="hint-container-title">max-age 仍然受到本地时间影响的原因</p><p>从上文可总结出影响强缓存使用期的因素有：</p><div class="language-http line-numbers-mode" data-highlighter="shiki" data-ext="http" data-title="http" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">age_value：响应首部 age 值</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">date_value：响应首部 date 值</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">request_time：浏览器缓存发起请求的本地时间</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">response_time：浏览器缓存收到响应的本地时间</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">now：客户端当前时间</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上 <code>request_time</code>、<code>response_time</code> 和 <code>now</code> 取的都是客户端本地时间，而 <code>now</code> 则受客户端本地时间修改的影响。</p><p>因此一旦<strong>修改了电脑客户端本地时间为未来时间，缓存使用期的计算便会受到影响（主要是停留缓存时间会变大），从而导致缓存使用期超出缓存新鲜度范围（强缓存失效）</strong>。</p></div><h3 id="从协商缓存到启发式缓存" tabindex="-1"><a class="header-anchor" href="#从协商缓存到启发式缓存"><span>从协商缓存到启发式缓存</span></a></h3><p>协商缓存可以看作是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。</p><p>即，<strong>浏览器启用协商缓存的前提是强缓存失效</strong>。</p><h4 id="协商缓存的生效流程" tabindex="-1"><a class="header-anchor" href="#协商缓存的生效流程"><span>协商缓存的生效流程</span></a></h4><div class="language-mermaid line-numbers-mode" data-highlighter="shiki" data-ext="mermaid" data-title="mermaid" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">sequenceDiagram</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    participant 浏览器</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    participant 浏览器缓存</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    participant 服务器</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    浏览器-&gt;&gt;服务器: 发送请求</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    服务器-&gt;&gt;浏览器: 返回响应 + Cache-Control 头部</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    alt 缓存未命中</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        浏览器-&gt;&gt;浏览器缓存: 请求缓存</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        浏览器缓存--&gt;&gt;浏览器: 无缓存</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        浏览器-&gt;&gt;服务器: 发送请求</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        服务器-&gt;&gt;浏览器: 返回响应 + Cache-Control 头部</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    else 缓存命中</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        浏览器--&gt;&gt;浏览器缓存: 请求缓存</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        浏览器缓存-&gt;&gt;浏览器: 返回缓存</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    浏览器-&gt;&gt;服务器: 发送请求 + If-Modified-Since 头部</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    服务器-&gt;&gt;浏览器: 返回 304 Not Modified 或新的响应 + Cache-Control 头部</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    alt 缓存未更新</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        浏览器--&gt;&gt;浏览器缓存: 更新缓存</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        浏览器缓存-&gt;&gt;浏览器: 返回更新后的缓存</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    else 缓存已更新</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        浏览器--&gt;&gt;浏览器缓存: 更新缓存</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        浏览器缓存--&gt;&gt;浏览器: 缓存已更新</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上图流程图描述了协商缓存的生效流程。具体来说，流程包括以下步骤：</p><ul><li>浏览器向服务器发送请求，并在响应中收到 <code>Cache-Control</code> 头部;</li><li>如果缓存未命中，则浏览器向浏览器缓存请求缓存，然后再次向服务器发送请求;</li><li>如果缓存命中，则浏览器从浏览器缓存中获取响应;</li><li>浏览器向服务器发送带有 <code>If-Modified-Since 头部的请求</code>，以检查缓存是否已更新;</li><li>如果缓存未更新，则浏览器更新缓存并将更新后的缓存返回;</li><li>如果缓存已更新，则浏览器从浏览器缓存中获取更新后的缓存。</li></ul><h4 id="缓存标识-last-modified-与-etag" tabindex="-1"><a class="header-anchor" href="#缓存标识-last-modified-与-etag"><span>缓存标识 Last-Modified 与 ETag</span></a></h4><p><code>Last-Modified</code> 和 <code>ETag</code> 都是用于标识缓存的标识符，用于在缓存验证失效流程中判断资源是否已更新。它们的作用相同，但实现方式不同。</p><p><code>Last-Modified</code> 是一个时间戳，表示资源的最后修改时间。</p><ul><li>当浏览器向服务器发送请求时，服务器会将资源的最后修改时间作为 <code>Last-Modified</code> 字段的值返回给浏览器。</li><li>当浏览器再次请求该资源时，会携带一个 <code>If-Modified-Since</code> 字段，其中的值为上次请求时返回的 Last-Modified 值。</li><li>服务器会将资源的最后修改时间与 If-Modified-Since 中的时间戳进行比较，如果时间戳相同，则表示资源未更新，可以直接使用缓存；</li><li>如果时间戳不同，则表示资源已更新，需要重新获取资源。</li></ul><p><code>ETag</code> 是一个字符串，表示资源的唯一标识符。</p><ul><li>当浏览器向服务器发送请求时，服务器会将资源的 ETag 值作为 ETag 字段的值返回给浏览器。</li><li>当浏览器再次请求该资源时，会携带一个 If-None-Match 字段，其中的值为上次请求时返回的 ETag 值。</li><li>服务器会将资源的 ETag 值与 If-None-Match 中的值进行比较，如果值相同，则表示资源未更新，可以直接使用缓存；</li><li>如果值不同，则表示资源已更新，需要重新获取资源。</li></ul><div class="hint-container info"><p class="hint-container-title">Last-Modified 有什么弊端？在服务器进行对比时一定精准吗？</p><ul><li><strong>时钟不同步问题</strong>：last-modified 头部信息是由服务器生成的，而浏览器是根据本地时间来判断缓存是否过期的。若两端时钟不同步，就会导致缓存判断不准确。</li><li><strong>精度问题</strong>：last-modified 的精度只能到秒级别，如果同一秒钟内多次修改了资源，就会导致缓存失效的判断不准确。</li><li><strong>修改时间被篡改问题</strong>：由于 last-modified 是由服务器生成的，因此如果服务器的时间被篡改了，就会导致缓存失效的判断不准确。</li></ul><p>相比于 <code>Last-Modified</code>，<code>ETag</code> 更加准确，因为它是资源的唯一标识符，不会因为时间戳精度问题而产生误差。 但是，由于 <code>ETag</code> 是字符串类型，需要服务器进行字符串比较，可能会带来一定的性能开销。</p><p>因此，在实际应用中，可以根据具体情况选择使用 Last-Modified 或 ETag。</p></div><h4 id="etag-原理及实现" tabindex="-1"><a class="header-anchor" href="#etag-原理及实现"><span>ETag 原理及实现</span></a></h4><p><code>ETag</code> 的值是由服务器生成的一个字符串，用于表示资源的特定版本。当客户端请求该资源时，可以将该值一起发送给服务器，服务器会根据该值来判断客户端缓存的版本是否过期。</p><p>通常用以下几种方式生成：</p><ol><li><p><strong>使用哈希算法生成</strong>：服务器可以使用哈希算法（如 MD5、SHA1 等）对资源内容进行计算，生成一个唯一的字符串作为 <code>ETag</code> 值。当资源内容发生变化时，<code>ETag</code> 值也会随之改变。</p></li><li><p><strong>使用版本号生成</strong>：服务器可以在资源的文件名或路径中加入版本号信息，每次更新版本号时，<code>ETag</code> 值也会随之改变。</p></li><li><p><strong>使用时间戳生成</strong>：服务器可以使用资源的最后修改时间作为 <code>ETag</code> 值。当资源内容发生变化时，最后修改时间也会随之改变，从而导致 <code>ETag</code> 值的改变。</p></li></ol><div class="hint-container info"><p class="hint-container-title">相关信息</p><p><code>ETag</code> 值的生成方式并没有统一的规定，不同的服务器实现可能采用不同的方式来生成 <code>ETag</code> 值。 但是，无论采用何种方式，<code>ETag</code> 值都应该是唯一的，并且能够准确地表示资源的特定版本。</p></div><blockquote><p>ETag 值又分为<strong>强 ETag 值</strong>和<strong>弱 ETag 值</strong>两种类型:</p><ul><li><p>强 ETag 值：指的是完全匹配资源内容的 ETag 值，也就是说，只有当两个 ETag 值完全相同，才表示两个资源内容完全一致；</p></li><li><p>弱 ETag 值：指的是不完全匹配资源内容的 ETag 值，即使两个 ETag 值不完全相同，但只要它们表示的是同一个资源，就可以认为这两个资源内容是一致的。弱 ETag 值会在字段值最开始处附加 W/，例如：W/&quot;abcde12345&quot;。</p></li></ul></blockquote><h4 id="启发式缓存" tabindex="-1"><a class="header-anchor" href="#启发式缓存"><span>启发式缓存</span></a></h4><blockquote><p>启发式缓存（Heuristic Caching），也称为启发式过期（Heuristic Expiration），它是一种基于启发式算法的缓存过期策略。</p></blockquote><p>当服务器没有提供明确的缓存过期时间或者缓存标识时，浏览器就会使用启发式算法来估算资源的过期时间。启发式算法通常会根据资源的一些属性（如大小、类型、URL 等）来估算过期时间，从而决定是否缓存该资源以及缓存多长时间。</p><p>注意：启发式缓存并不是一种精确的缓存策略，它只是一种基于经验的估算方法。因此，使用启发式缓存可能会导致一些资源过早地失效或者过晚地失效，从而影响用户的体验。 为了避免这种情况，建议在服务器端尽可能提供明确的缓存过期时间或者缓存标识，以确保缓存的准确性和有效性。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://juejin.cn/book/6994678547826606095" target="_blank" rel="noopener noreferrer">前端缓存技术与方案解析 - 劳卜 - 掘金小册</a></li><li><a href="https://juejin.cn/post/6992843117963509791" target="_blank" rel="noopener noreferrer">彻底理解浏览器的缓存机制 - 掘金</a></li><li><a href="https://github.com/wsafight/personBlog/issues/34" target="_blank" rel="noopener noreferrer">手写一个基于 Proxy 的缓存库 · Issue #34 · wsafight/personBlog</a></li></ul>`,95))])}const o=e(l,[["render",r],["__file","fed-cache-and-tec-solutions1.html.vue"]]),c=JSON.parse('{"path":"/code/basic/fed-cache-and-tec-solutions1.html","title":"前端缓存与技术方案（上）","lang":"zh-CN","frontmatter":{"title":"前端缓存与技术方案（上）","date":"2023-02-17T00:00:00.000Z","category":["基础"],"tag":["缓存"],"description":"前言 缓存的合理使用可提升网页性能。 什么是缓存（cache）？ 缓存是计算机系统中的一种技术，用于临时存储经常访问的数据，以加快数据访问速度。缓存通常位于数据访问路径的中间，可以在数据访问时快速提供数据，而无需每次都从原始数据源获取数据。缓存可以是硬件或软件实现的，可以在多个层次上实现，例如浏览器缓存、操作系统缓存、CPU 缓存等。缓存的使用可以显著...","head":[["meta",{"property":"og:url","content":"https://huguangju.cn/code/basic/fed-cache-and-tec-solutions1.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"前端缓存与技术方案（上）"}],["meta",{"property":"og:description","content":"前言 缓存的合理使用可提升网页性能。 什么是缓存（cache）？ 缓存是计算机系统中的一种技术，用于临时存储经常访问的数据，以加快数据访问速度。缓存通常位于数据访问路径的中间，可以在数据访问时快速提供数据，而无需每次都从原始数据源获取数据。缓存可以是硬件或软件实现的，可以在多个层次上实现，例如浏览器缓存、操作系统缓存、CPU 缓存等。缓存的使用可以显著..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-21T05:33:38.000Z"}],["meta",{"property":"article:tag","content":"缓存"}],["meta",{"property":"article:published_time","content":"2023-02-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-21T05:33:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"前端缓存与技术方案（上）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-02-17T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-21T05:33:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"huguangju\\",\\"url\\":\\"https://huguangju.cn\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[{"level":3,"title":"什么是缓存（cache）？","slug":"什么是缓存-cache","link":"#什么是缓存-cache","children":[]},{"level":3,"title":"什么是前端缓存？","slug":"什么是前端缓存","link":"#什么是前端缓存","children":[]},{"level":3,"title":"前端有哪此缓存？","slug":"前端有哪此缓存","link":"#前端有哪此缓存","children":[]}]},{"level":2,"title":"HTTP 缓存","slug":"http-缓存","link":"#http-缓存","children":[{"level":3,"title":"与缓存有关的首部字段名","slug":"与缓存有关的首部字段名","link":"#与缓存有关的首部字段名","children":[]},{"level":3,"title":"强缓存","slug":"强缓存","link":"#强缓存","children":[]},{"level":3,"title":"缓存新鲜度与使用期算法","slug":"缓存新鲜度与使用期算法","link":"#缓存新鲜度与使用期算法","children":[]},{"level":3,"title":"从协商缓存到启发式缓存","slug":"从协商缓存到启发式缓存","link":"#从协商缓存到启发式缓存","children":[]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1732167218000,"updatedTime":1732167218000,"contributors":[{"name":"huguangju","email":"huguangjugit@163.com","commits":1}]},"readingTime":{"minutes":17.15,"words":5144},"filePathRelative":"code/basic/fed-cache-and-tec-solutions1.md","localizedDate":"2023年2月17日","excerpt":"<h2>前言</h2>\\n<p>缓存的合理使用可<strong>提升网页性能</strong>。</p>\\n<h3>什么是缓存（cache）？</h3>\\n<p>缓存是计算机系统中的一种技术，用于临时存储经常访问的数据，以加快数据访问速度。缓存通常位于数据访问路径的中间，可以在数据访问时快速提供数据，而无需每次都从原始数据源获取数据。缓存可以是硬件或软件实现的，可以在多个层次上实现，例如浏览器缓存、操作系统缓存、CPU 缓存等。缓存的使用可以显著提高系统性能，减少对原始数据源的访问次数，从而减少系统资源的占用和延迟。</p>\\n<p>可以看出，缓存的重点在于<strong>访问速度快、性能高</strong>。</p>\\n","autoDesc":true}');export{o as comp,c as data};
